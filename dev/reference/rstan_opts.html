<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Rstan Options — rstan_opts • EpiNow2</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>


<!-- docsearch -->
<script src="../docsearch.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.3/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous" />
<link href="../docsearch.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>



<meta property="og:title" content="Rstan Options — rstan_opts" />
<meta property="og:description" content="

Defines a list specifying the arguments passed to underlying rstan
functions via rstan_sampling_opts and rstan_vb_opts.Custom settings can be supplied
which override the defaults." />
<meta property="og:image" content="epiforecasts.io/EpiNow2/reference/figures/unnamed-chunk-13-1.png" />
<meta property="og:image:alt" content="Example estimates produced by EpiNow2 of the reproduction number, cases by date of infection and cases by date of report" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:creator" content="@seabbs" />
<meta name="twitter:site" content="@cmmid_lshtm" />


<meta name="robots" content="noindex">

<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">EpiNow2</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">1.3.0.7</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="../reference/index.html">
    <span class="fa fa-file-code-o"></span>
     
    Functions
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/epiforecasts/EpiNow2">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
      
      <form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
        </div>
      </form>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Rstan Options</h1>
    
    <div class="hidden name"><code>rstan_opts.Rd</code></div>
    </div>

    <div class="ref-description">
    <p><a href='https://www.tidyverse.org/lifecycle/#stable'><img src='figures/lifecycle-stable.svg' alt='Stable lifecycle'></a>

Defines a list specifying the arguments passed to underlying <code>rstan</code>
functions via <code>rstan_sampling_opts</code> and <code>rstan_vb_opts</code>.Custom settings can be supplied
which override the defaults.</p>
    </div>

    <pre class="usage"><span class='fu'>rstan_opts</span><span class='op'>(</span>object <span class='op'>=</span> <span class='cn'>NULL</span>, samples <span class='op'>=</span> <span class='fl'>2000</span>, method <span class='op'>=</span> <span class='st'>"sampling"</span>, <span class='va'>...</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>object</th>
      <td><p>Stan model object. By default uses the compiled package default.</p></td>
    </tr>
    <tr>
      <th>samples</th>
      <td><p>Numeric, default 1000. Overall number of posterior samples.
When using multiple chains iterations per chain is samples / chains.</p></td>
    </tr>
    <tr>
      <th>method</th>
      <td><p>A character string, defaulting to sampling. Currently supports
<code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html'>rstan::sampling</a></code> ("sampling") or <code>rstan:vb</code> ("vb").</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Additional parameters to pass  underlying option functions.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A list of arguments to pass to the appropriate rstan functions.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p>rstan_sampling_opts rstan_vb_opts</p></div>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='fu'>rstan_opts</span><span class='op'>(</span>samples <span class='op'>=</span> <span class='fl'>1000</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt; // discretised truncated gamma pmf
#&gt; vector discretised_gamma_pmf(int[] y, real mu, real sigma, int max_val) {
#&gt;   int n = num_elements(y);
#&gt;   vector[n] pmf;
#&gt;   real trunc_pmf;
#&gt;   // calculate alpha and beta for gamma distribution
#&gt;   real c_sigma = sigma + 1e-5;
#&gt;   real alpha = ((mu)/ c_sigma)^2;
#&gt;   real beta = (mu) / (c_sigma^2);
#&gt;   //account for numerical issues
#&gt;   alpha = alpha &lt;= 0 ? 1e-5 : alpha;
#&gt;   beta = beta &lt;= 0 ? 1e-5 : beta;
#&gt;   alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;   beta = is_inf(beta) ? 1e8 : beta; 
#&gt;   // calculate pmf
#&gt;   trunc_pmf = gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta);
#&gt;   for (i in 1:n){
#&gt;     pmf[i] = (gamma_cdf(y[i] + 1, alpha, beta) - gamma_cdf(y[i], alpha, beta)) / 
#&gt;     trunc_pmf;
#&gt;   }
#&gt;   return(pmf);
#&gt; }
#&gt; 
#&gt; // discretised truncated lognormal pmf
#&gt; vector discretised_lognormal_pmf(int[] y, real mu, real sigma, int max_val) {
#&gt;   int n = num_elements(y);
#&gt;   vector[n] pmf;
#&gt;   real small = 1e-5;
#&gt;   real c_sigma = sigma &lt;= 0 ? small : sigma;
#&gt;   real c_mu = mu &lt;= 0 ? small : mu;
#&gt;   vector[n] adj_y = to_vector(y) + small;
#&gt;   vector[n] upper_y = (log(adj_y + 1) - c_mu) / c_sigma;
#&gt;   vector[n] lower_y = (log(adj_y) - c_mu) / c_sigma;
#&gt;   real max_cdf = normal_cdf((log(max_val + small) - c_mu) / c_sigma, 0.0, 1.0);
#&gt;   real min_cdf = normal_cdf((log(small) - c_mu) / c_sigma, 0.0, 1.0);
#&gt;   real trunc_cdf = max_cdf - min_cdf;
#&gt;   for (i in 1:n) {
#&gt;     pmf[i] = (normal_cdf(upper_y[i], 0.0, 1.0) - normal_cdf(lower_y[i], 0.0, 1.0)) /
#&gt;     trunc_cdf;
#&gt;   }
#&gt;   return(pmf);
#&gt; }
#&gt; 
#&gt; // reverse a mf
#&gt; vector reverse_mf(vector pmf, int max_pmf) {
#&gt;   vector[max_pmf] rev_pmf;
#&gt;   for (d in 1:max_pmf) {
#&gt;     rev_pmf[d] = pmf[max_pmf - d + 1];
#&gt;   }
#&gt;   return rev_pmf;
#&gt; }
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector rev_pmf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pmf = num_elements(rev_pmf);
#&gt;     vector[t] conv_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s],
#&gt;                                      tail(rev_pmf, min(max_pmf, s)));
#&gt;     }
#&gt;    return(conv_cases);
#&gt;   }
#&gt; 
#&gt; 
#&gt; // convolve latent infections to reported (but still unobserved) cases
#&gt; vector convolve_to_report(vector infections, 
#&gt;                           real[] delay_mean, 
#&gt;                           real[] delay_sd,
#&gt;                           int[] max_delay,
#&gt;                           int seeding_time) {
#&gt;   int t = num_elements(infections);
#&gt;   vector[t - seeding_time] reports;
#&gt;   vector[t] unobs_reports = infections;
#&gt;   int delays = num_elements(delay_mean);
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       vector[max_delay[s]] pmf = rep_vector(1e-5, max_delay[s]);
#&gt;       int delay_indexes[max_delay[s]];
#&gt;       for (i in 1:max_delay[s]) {
#&gt;         delay_indexes[i] = max_delay[s] - i;
#&gt;       }
#&gt;       pmf = pmf + discretised_lognormal_pmf(delay_indexes, delay_mean[s],
#&gt;                                             delay_sd[s], max_delay[s]);
#&gt;       unobs_reports = convolve(unobs_reports, pmf);
#&gt;     }
#&gt;     reports = unobs_reports[(seeding_time + 1):t];
#&gt;   }else{
#&gt;     reports = infections[(seeding_time + 1):t];
#&gt;   }
#&gt;   return(reports);
#&gt; }
#&gt; 
#&gt; void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, 
#&gt;                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){
#&gt;     int delays = num_elements(delay_mean);
#&gt;     if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;
#&gt;     }
#&gt;   }
#&gt; }
#&gt; 
#&gt; // eigenvalues for approximate hilbert space gp
#&gt; // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; real lambda(real L, int m) {
#&gt;   real lam;
#&gt;   lam = ((m*pi())/(2*L))^2;
#&gt;   return lam;
#&gt; }
#&gt; // eigenfunction for approximate hilbert space gp
#&gt; // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; vector phi(real L, int m, vector x) {
#&gt;   vector[rows(x)] fi;
#&gt;   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt;   return fi;
#&gt; }	
#&gt; // spectral density of the exponential quadratic kernal
#&gt; real spd_se(real alpha, real rho, real w) {
#&gt;   real S;
#&gt;   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt;   return S;
#&gt; }
#&gt; // spectral density of the Matern 3/2 kernel
#&gt; real spd_matern(real alpha, real rho, real w) {
#&gt;   real S;
#&gt;   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2;
#&gt;   return S;
#&gt; }
#&gt; // setup gaussian process noise dimensions
#&gt; int setup_noise(int ot_h, int t, int horizon, int estimate_r, 
#&gt;                 int stationary, int future_fixed, int fixed_from) {
#&gt;   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;
#&gt;   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time; 
#&gt;   return(noise_terms);
#&gt; }
#&gt; // setup approximate gaussian process
#&gt; matrix setup_gp(int M, real L, int dimension) {
#&gt;   vector[dimension] time;
#&gt;   matrix[dimension, M] PHI;
#&gt;   real half_dim = dimension / 2.0;
#&gt;   for (s in 1:dimension) {
#&gt;     time[s] = (s - half_dim) / half_dim;
#&gt;   }
#&gt;   for (m in 1:M){ 
#&gt;     PHI[,m] = phi(L, m, time); 
#&gt;   }
#&gt;   return(PHI);
#&gt; }
#&gt; // update gaussian process using spectral densities
#&gt; vector update_gp(matrix PHI, int M, real L, real alpha, 
#&gt;                  real rho, vector eta, int type) {
#&gt;   vector[M] diagSPD;    // spectral density
#&gt;   vector[M] SPD_eta;    // spectral density * noise
#&gt;   int noise_terms = rows(PHI);
#&gt;   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);
#&gt;   real unit_rho = rho / noise_terms;
#&gt;   // GP in noise - spectral densities
#&gt;   if (type == 0) {
#&gt;     for(m in 1:M){ 
#&gt;       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); 
#&gt;     }
#&gt;   }else if (type == 1) {
#&gt;     for(m in 1:M){ 
#&gt;       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); 
#&gt;     }
#&gt;   }
#&gt;   SPD_eta = diagSPD .* eta;
#&gt;   noise = noise + PHI[,] * SPD_eta;
#&gt;   return(noise);
#&gt; }
#&gt; // priors for gaussian process
#&gt; void gaussian_process_lp(real rho, real alpha, vector eta,
#&gt;                          real ls_meanlog, real ls_sdlog,
#&gt;                          real ls_min, real ls_max, real alpha_sd) {
#&gt;   rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max];
#&gt;   alpha ~ normal(0, alpha_sd);
#&gt;   eta ~ std_normal();
#&gt; }
#&gt; 
#&gt; // Update an individual breakpoint effect
#&gt; real update_breakpoints(real input_R, real[] bp_effects,
#&gt;                         int bp_index, int at_bp,
#&gt;                         int stationary) {
#&gt;   real R = input_R;
#&gt;   if (stationary) {
#&gt;     if (bp_index &gt; 0) {
#&gt;       R += sum(bp_effects[1:bp_index]);
#&gt;       }
#&gt;   }else{
#&gt;     if (at_bp) {
#&gt;       R += bp_effects[bp_index];
#&gt;     }
#&gt;   }               
#&gt;   return(R);
#&gt; }
#&gt; // update an individual R
#&gt; real update_R(vector R, vector noise, int noise_terms,
#&gt;               int index, int stationary) {
#&gt;   real cR = R[index];
#&gt;   if (noise_terms &gt; 0) {
#&gt;     if (stationary){
#&gt;       if (index &lt;= noise_terms) {
#&gt;         cR += noise[index];
#&gt;       }else{
#&gt;         if (index &gt; 1) {
#&gt;            cR = R[index - 1];
#&gt;         }
#&gt;       }
#&gt;     }else{
#&gt;       if (index &lt;= (noise_terms + 1)) {
#&gt;         cR = R[index - 1] + noise[index - 1];
#&gt;       }else{
#&gt;         cR = R[index - 1];
#&gt;       }
#&gt;     }
#&gt;   }
#&gt;   return(cR);
#&gt; }
#&gt; // update a vector of Rts
#&gt; vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,
#&gt;                  real[] bp_effects, int stationary) {
#&gt;   // define control parameters
#&gt;   int noise_terms = num_elements(noise);
#&gt;   int i_stationary = noise_terms &gt; 0 ? stationary : 1;
#&gt;   int t = num_elements(input_R);
#&gt;   int bp_n = num_elements(bp_effects);
#&gt;   int bp_in = 0;
#&gt;   int at_bp = 0;
#&gt;   int index;
#&gt;   vector[t] R;
#&gt;   // initialise Rt
#&gt;   if (i_stationary) {
#&gt;     R = rep_vector(log_R, t);
#&gt;     index = 1;
#&gt;   }else{
#&gt;     R[1] = log_R;
#&gt;     index = 2;
#&gt;   }
#&gt;   // iteratively update Rt
#&gt;   for (s in index:t) {
#&gt;     R[s] = update_R(R, noise, noise_terms, s, i_stationary);
#&gt;     if (bp_n &gt; 0) {
#&gt;       at_bp = bps[s];
#&gt;       bp_in += at_bp;
#&gt;       R[s] = update_breakpoints(R[s], bp_effects, bp_in, at_bp, i_stationary);
#&gt;     }
#&gt;   }
#&gt;   // convert to correct scale
#&gt;   R = exp(R);
#&gt;   return(R);
#&gt; }
#&gt; // Rt priors
#&gt; void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth,
#&gt;            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time,
#&gt;            real r_logmean, real r_logsd, real prior_infections, 
#&gt;            real prior_growth) {
#&gt;   // prior on R
#&gt;   log_R ~ normal(r_logmean, r_logsd);
#&gt;   //breakpoint effects on Rt
#&gt;   if (bp_n &gt; 0) {
#&gt;     bp_sd[1] ~ normal(0, 0.1) T[0,];
#&gt;     bp_effects ~ normal(0, bp_sd[1]);
#&gt;   }
#&gt;   // initial infections
#&gt;   initial_infections ~ normal(prior_infections, 0.2);
#&gt;   if (seeding_time &gt; 1) {
#&gt;     initial_growth ~ normal(prior_growth, 0.2);
#&gt;   }
#&gt; }
#&gt; 
#&gt; // calculate infectiousness (weighted sum of the generation time and infections)
#&gt; // for a single time point
#&gt; real update_infectiousness(vector infections, vector gt_pmf,
#&gt;                            int seeding_time, int max_gt, int index){
#&gt;   int inf_start = max(1, (index + seeding_time - max_gt));
#&gt;   int inf_end = (index + seeding_time - 1);
#&gt;   int pmf_accessed = min(max_gt, index + seeding_time - 1);
#&gt;   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));
#&gt;   return(new_inf);
#&gt; }
#&gt; // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections)
#&gt; vector generate_infections(vector oR, int uot, 
#&gt;                            real[] gt_mean, real[] gt_sd, int max_gt,
#&gt;                            real[] initial_infections, real[] initial_growth,
#&gt;                            int pop, int ht) {
#&gt;   // time indices and storage
#&gt;   int ot = num_elements(oR);
#&gt;   int nht = ot - ht;
#&gt;   int t = ot + uot;
#&gt;   vector[ot] R = oR;
#&gt;   real exp_adj_Rt;
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   vector[ot] cum_infections = rep_vector(0, ot);
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot);
#&gt;   // generation time pmf
#&gt;   vector[max_gt] gt_pmf = rep_vector(1e-5, max_gt);   
#&gt;   int gt_indexes[max_gt];
#&gt;   for (i in 1:(max_gt)) {
#&gt;     gt_indexes[i] = max_gt - i + 1;
#&gt;   }
#&gt;   gt_pmf = gt_pmf + discretised_gamma_pmf(gt_indexes, gt_mean[1], gt_sd[1], max_gt);
#&gt;   // Initialise infections using daily growth
#&gt;   infections[1] = exp(initial_infections[1]);
#&gt;   if (uot &gt; 1) {
#&gt;     for (s in 2:uot) {
#&gt;       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1));
#&gt;     }
#&gt;   }
#&gt;   // calculate cumulative infections
#&gt;   if (pop) {
#&gt;     cum_infections[1] = sum(infections[1:uot]);
#&gt;   }
#&gt;   // iteratively update infections
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s);
#&gt;     if (pop &amp;&amp; s &gt; nht) {
#&gt;       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht]));
#&gt;       exp_adj_Rt = exp_adj_Rt &gt; 1 ? 1 : exp_adj_Rt;
#&gt;       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt);
#&gt;     }else{
#&gt;       infections[s + uot] += R[s] * infectiousness[s];
#&gt;     }
#&gt;     if (pop &amp;&amp; s &lt; ot) {
#&gt;       cum_infections[s + 1] = cum_infections[s] + infections[s + uot];
#&gt;     }
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; // backcalculate infections using mean shifted cases and non-parametric noise
#&gt; vector deconvolve_infections(vector shifted_cases, vector noise, int fixed) {
#&gt;   int t = num_elements(shifted_cases);
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   if(!fixed) {
#&gt;     infections = infections + shifted_cases .* exp(noise);
#&gt;   }else{
#&gt;     infections = infections + shifted_cases;
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; // Update the log density for the generation time distribution mean and sd
#&gt; void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, 
#&gt;                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {
#&gt;     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;
#&gt;     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;
#&gt; }
#&gt; 
#&gt; 
#&gt; // apply day of the week effect
#&gt; vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {
#&gt;   int t = num_elements(reports);
#&gt;   // scale day of week effect
#&gt;   vector[7] scaled_effect = 7 * effect;
#&gt;   vector[t] scaled_reports;
#&gt;   for (s in 1:t) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];
#&gt;    }
#&gt;   return(scaled_reports);
#&gt; }
#&gt; // Scale observations by fraction reported and update log density of 
#&gt; // fraction reported
#&gt; vector scale_obs(vector reports, real frac_obs) {
#&gt;   int t = num_elements(reports);
#&gt;   vector[t] scaled_reports;
#&gt;   scaled_reports = reports * frac_obs;
#&gt;   return(scaled_reports);
#&gt; }
#&gt; // Calculate a truncation CMF
#&gt; vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) {
#&gt;     int  trunc_indexes[trunc_max];
#&gt;     vector[trunc_max] cmf;
#&gt;     for (i in 1:(trunc_max)) {
#&gt;       trunc_indexes[i] = i - 1;
#&gt;     }
#&gt;     cmf = discretised_lognormal_pmf(trunc_indexes, trunc_mean, trunc_sd, trunc_max);   
#&gt;     cmf[1] = cmf[1] + 1e-8;
#&gt;     cmf = cumulative_sum(cmf);
#&gt;     cmf = reverse_mf(cmf, trunc_max);
#&gt;     return(cmf);
#&gt; }
#&gt; // Truncate observed data by some truncation distribution
#&gt; vector truncate(vector reports, real[] truncation_mean, real[] truncation_sd, 
#&gt;                 int[] truncation_max, int reconstruct) {
#&gt;   int t = num_elements(reports);
#&gt;   int truncation = num_elements(truncation_mean);
#&gt;   vector[t] trunc_reports = reports;
#&gt;   if (truncation) {
#&gt;     // Calculate cmf of truncation delay
#&gt;     int trunc_max = truncation_max[1] &gt; t ? t : truncation_max[1];
#&gt;     int  trunc_indexes[trunc_max];
#&gt;     vector[trunc_max] cmf;
#&gt;     int first_t = t - trunc_max + 1;
#&gt;     cmf = truncation_cmf(truncation_mean[1], truncation_sd[1], trunc_max);
#&gt;     // Apply cdf of truncation delay to truncation max last entries in reports
#&gt;     if (reconstruct) {
#&gt;       trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf;
#&gt;     }else{
#&gt;       trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf;
#&gt;     }
#&gt;   }
#&gt;   return(trunc_reports);
#&gt; }
#&gt; // Truncation distribution priors
#&gt; void truncation_lp(real[] truncation_mean, real[] truncation_sd, 
#&gt;                    real[] trunc_mean_mean, real[] trunc_mean_sd, 
#&gt;                    real[] trunc_sd_mean, real[] trunc_sd_sd) {
#&gt;   int truncation = num_elements(truncation_mean);
#&gt;   if (truncation) {
#&gt;     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd);
#&gt;     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd);
#&gt;   }                     
#&gt; }
#&gt; // update log density for reported cases
#&gt; void report_lp(int[] cases, vector reports, 
#&gt;                real[] rep_phi, int phi_prior,
#&gt;                int model_type, real weight) {
#&gt;   real sqrt_phi;
#&gt;   if (model_type) {
#&gt;     // the reciprocal overdispersion parameter (phi)
#&gt;     rep_phi[model_type] ~ normal(0, phi_prior) T[0,];
#&gt;     sqrt_phi = 1 / sqrt(rep_phi[model_type]);
#&gt;     // defer to poisson if phi is large, to avoid overflow
#&gt;     if (sqrt_phi &gt; 1e4) {
#&gt;       target += poisson_lpmf(cases | reports) * weight;
#&gt;     } else {
#&gt;       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi) * weight;
#&gt;     }
#&gt;   } else {
#&gt;     target += poisson_lpmf(cases | reports) * weight;
#&gt;   }
#&gt; }
#&gt; 
#&gt; // calculate Rt directly from inferred infections
#&gt; vector calculate_Rt(vector infections, int seeding_time,
#&gt;                     real gt_mean, real gt_sd, int max_gt,
#&gt;                     int smooth) {
#&gt;   vector[max_gt] gt_pmf;  
#&gt;   int gt_indexes[max_gt];
#&gt;   int t = num_elements(infections);
#&gt;   int ot = t - seeding_time;
#&gt;   vector[ot] R;
#&gt;   vector[ot] sR;
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot); 
#&gt;   // calculate PMF of the generation time
#&gt;   for (i in 1:(max_gt)) {
#&gt;     gt_indexes[i] = max_gt - i + 1;
#&gt;   }
#&gt;   gt_pmf = discretised_gamma_pmf(gt_indexes, gt_mean, gt_sd, max_gt);
#&gt;   // calculate Rt using Cori et al. approach
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     R[s] = infections[s + seeding_time] / infectiousness[s];
#&gt;   }
#&gt;   if (smooth) {
#&gt;     for (s in 1:ot) {
#&gt;       real window = 0;
#&gt;       sR[s] = 0;
#&gt;       for (i in max(1, s - smooth):min(ot, s + smooth)) {
#&gt;         sR[s] += R[i];
#&gt;         window += 1;
#&gt;       }
#&gt;       sR[s] = sR[s] / window;
#&gt;     }
#&gt;   }else{
#&gt;     sR = R;
#&gt;   }
#&gt;   return(sR);
#&gt; }
#&gt; // Convert an estimate of Rt to growth
#&gt; real[] R_to_growth(vector R, real gt_mean, real gt_sd) {
#&gt;   real k = pow(gt_sd / gt_mean, 2);
#&gt;   int t = num_elements(R);
#&gt;   real r[t];
#&gt;   for (s in 1:t) {
#&gt;     r[s] = (pow(R[s], k) - 1) / (k * gt_mean);
#&gt;   } 
#&gt;   return(r);
#&gt; }
#&gt; // sample reported cases from the observation model
#&gt; int[] report_rng(vector reports, real[] rep_phi, int model_type) {
#&gt;   int t = num_elements(reports);
#&gt;   int sampled_reports[t];
#&gt;   real sqrt_phi;
#&gt;   if (model_type) {
#&gt;     sqrt_phi = 1 / sqrt(rep_phi[model_type]);
#&gt;     for (s in 1:t) {
#&gt;       // defer to poisson if phi is large, to avoid overflow
#&gt;       if (sqrt_phi &gt; 1e4) {
#&gt;         sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;       } else {
#&gt;         sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], sqrt_phi);
#&gt;       }
#&gt;     }
#&gt;   }else {
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt;   return(sampled_reports);
#&gt; }
#&gt; 
#&gt; 
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt; 
#&gt;   int t;                                            // unobserved time
#&gt;   int seeding_time;                                 // time period used for seeding and not observed
#&gt;   int horizon;                                      // forecast horizon
#&gt;   int future_time;                                  // time in future for Rt
#&gt;   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;               // prior infections (for backcalculation)
#&gt; 
#&gt;   int delays;                  // no. of delay distributions
#&gt;   real delay_mean_sd[delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays];       // maximum incubation period
#&gt; 
#&gt;   real L;				                     // boundary value for infections gp
#&gt;   int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt;   real ls_meanlog;                   // meanlog for gp lengthscale prior
#&gt;   real ls_sdlog;                     // sdlog for gp lengthscale prior
#&gt;   real&lt;lower=0&gt; ls_min;              // Lower bound for the lengthscale  
#&gt;   real&lt;lower=0&gt; ls_max;              // Upper bound for the lengthscale
#&gt;   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter
#&gt;   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern
#&gt;   int stationary;                    // is underlying gaussian process first or second order
#&gt;   int fixed;                         //  should a gaussian process be used
#&gt; 
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt; 
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real prior_infections;             // prior for initial infections
#&gt;   real prior_growth;                 // prior on initial growth rate
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   int bp_n;                          // no of breakpoints (0 = no breakpoints)
#&gt;   int breakpoints[t - seeding_time]; // when do breakpoints occur 
#&gt;   int future_fixed;                  // is underlying future Rt assumed to be fixed
#&gt;   int fixed_from;                    // Reference date for when Rt estimation should be fixed
#&gt;   int pop;                           // Initial susceptible population
#&gt;   int rt_half_window;                // Half the moving average window used when calculating Rt
#&gt; 
#&gt;   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int week_effect;                   // should a day of the week effect be estimated
#&gt;   int truncation;                    // 1/0 indicating if truncation should be adjusted for
#&gt;   real trunc_mean_mean[truncation];  // truncation mean of mean
#&gt;   real trunc_mean_sd[truncation];    // truncation sd of mean
#&gt;   real trunc_sd_mean[truncation];    // truncation mean of sd
#&gt;   real trunc_sd_sd[truncation];      // truncation sd of sd
#&gt;   int max_truncation[truncation];    // maximum truncation supported
#&gt;   int obs_scale;                     // logical controlling scaling of observations
#&gt;   real obs_scale_mean;               // mean scaling factor for observations
#&gt;   real obs_scale_sd;                 // standard deviation of observation scaling
#&gt;   real obs_weight;                   // weight given to observation in log density
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   // observations
#&gt;   int ot = t - seeding_time - horizon;  // observed time
#&gt;   int ot_h = ot + horizon;  // observed time + forecast horizon
#&gt;   // gaussian process
#&gt;   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);
#&gt;   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function 
#&gt;   // Rt
#&gt;   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); 
#&gt;   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); 
#&gt; }
#&gt; 
#&gt; parameters{
#&gt;   // gaussian process
#&gt;   real&lt;lower = ls_min,upper=ls_max&gt; rho[fixed ? 0 : 1];  // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];     // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;                // unconstrained noise
#&gt;   // Rt
#&gt;   vector[estimate_r] log_R;                 // baseline reproduction number estimate (log)
#&gt;   real initial_infections[estimate_r] ;     // seed infections 
#&gt;   real initial_growth[estimate_r &amp;&amp; seeding_time &gt; 1 ? 1 : 0]; // seed growth rate
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];     // mean of generation time
#&gt;   real&lt;lower = 0&gt; gt_sd[estimate_r];       // sd of generation time
#&gt;   real&lt;lower = 0&gt; bp_sd[bp_n &gt; 0 ? 1 : 0]; // standard deviation of breakpoint effect
#&gt;   real bp_effects[bp_n];                  // Rt breakpoint effects
#&gt;   // observation model
#&gt;   real delay_mean[delays];                // mean of delays
#&gt;   real delay_sd[delays];                 // sd of delays
#&gt;   simplex[week_effect ? 7 : 1] day_of_week_simplex;   // day of week reporting effect 
#&gt;   real&lt;lower = 0&gt; frac_obs[obs_scale];   // fraction of cases that are ultimately observed
#&gt;   real truncation_mean[truncation];      // mean of truncation
#&gt;   real truncation_sd[truncation];        // sd of truncation
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];   // overdispersion of the reporting process
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise  generated by the gaussian process
#&gt;   vector[estimate_r &gt; 0 ? ot_h : 0] R;                    // reproduction number
#&gt;   vector[t] infections;                                   // latent infections
#&gt;   vector[ot_h] reports;                                   // estimated reported cases
#&gt;   vector[ot] obs_reports;                                 // observed estimated reported cases
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type);
#&gt;   }
#&gt;   // Estimate latent infections
#&gt;   if (estimate_r) {
#&gt;     // via Rt
#&gt;     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);
#&gt;     infections = generate_infections(R, seeding_time, gt_mean, gt_sd, max_gt,
#&gt;                                      initial_infections, initial_growth,
#&gt;                                      pop, future_time);
#&gt;   }else{
#&gt;     // via deconvolution
#&gt;     infections = deconvolve_infections(shifted_cases, noise, fixed);
#&gt;   }
#&gt;   // convolve from latent infections to mean of observations
#&gt;   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);
#&gt;  // weekly reporting effect
#&gt;  if (week_effect) {
#&gt;    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);
#&gt;   }
#&gt;   // scaling of reported cases by fraction oberserved
#&gt;  if (obs_scale) {
#&gt;    reports = scale_obs(reports, frac_obs[1]);
#&gt;  }
#&gt;  // truncate near time cases to observed reports 
#&gt;  obs_reports = truncate(reports[1:ot], truncation_mean, truncation_sd, max_truncation, 0);
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;     gaussian_process_lp(rho[1], alpha[1], eta, ls_meanlog, 
#&gt;                         ls_sdlog, ls_min, ls_max, alpha_sd);
#&gt;   }
#&gt;   // penalised priors for delay distributions
#&gt;   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);
#&gt;   // priors for truncation
#&gt;   truncation_lp(truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd, 
#&gt;                 trunc_sd_mean, trunc_sd_sd);
#&gt;   if (estimate_r) {
#&gt;     // priors on Rt
#&gt;     rt_lp(log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, seeding_time,
#&gt;           r_logmean, r_logsd, prior_infections, prior_growth);
#&gt;     // penalised_prior on generation interval
#&gt;     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);
#&gt;   }
#&gt;   // prior observation scaling
#&gt;   if (obs_scale) {
#&gt;     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,];
#&gt;   }
#&gt;   // observed reports from mean of reports
#&gt;   report_lp(cases, obs_reports, rep_phi, 1, model_type, obs_weight);
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[ot_h]; 
#&gt;   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;
#&gt;   real r[ot_h];
#&gt;   if (estimate_r){
#&gt;     // estimate growth from estimated Rt
#&gt;     r = R_to_growth(R, gt_mean[1], gt_sd[1]);
#&gt;   }else{
#&gt;     // sample generation time
#&gt;     real gt_mean_sample = normal_rng(gt_mean_mean, gt_mean_sd);
#&gt;     real gt_sd_sample = normal_rng(gt_sd_mean, gt_sd_sd);
#&gt;     // calculate Rt using infections and generation time
#&gt;     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_mean_sample, 
#&gt;                          max_gt, rt_half_window);
#&gt;     // estimate growth from calculated Rt
#&gt;     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);
#&gt;   }
#&gt;   // simulate reported cases
#&gt;   imputed_reports = report_rng(reports, rep_phi, model_type);
#&gt; } 
#&gt; 
#&gt; $method
#&gt; [1] "sampling"
#&gt; 
#&gt; $cores
#&gt; [1] 1
#&gt; 
#&gt; $warmup
#&gt; [1] 250
#&gt; 
#&gt; $chains
#&gt; [1] 4
#&gt; 
#&gt; $save_warmup
#&gt; [1] FALSE
#&gt; 
#&gt; $seed
#&gt; [1] 55029789
#&gt; 
#&gt; $future
#&gt; [1] FALSE
#&gt; 
#&gt; $max_execution_time
#&gt; [1] Inf
#&gt; 
#&gt; $control
#&gt; $control$adapt_delta
#&gt; [1] 0.98
#&gt; 
#&gt; $control$max_treedepth
#&gt; [1] 15
#&gt; 
#&gt; 
#&gt; $iter
#&gt; [1] 500
#&gt; </div><div class='input'>
<span class='co'># using vb</span>
<span class='fu'>rstan_opts</span><span class='op'>(</span>method <span class='op'>=</span> <span class='st'>"vb"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt; // discretised truncated gamma pmf
#&gt; vector discretised_gamma_pmf(int[] y, real mu, real sigma, int max_val) {
#&gt;   int n = num_elements(y);
#&gt;   vector[n] pmf;
#&gt;   real trunc_pmf;
#&gt;   // calculate alpha and beta for gamma distribution
#&gt;   real c_sigma = sigma + 1e-5;
#&gt;   real alpha = ((mu)/ c_sigma)^2;
#&gt;   real beta = (mu) / (c_sigma^2);
#&gt;   //account for numerical issues
#&gt;   alpha = alpha &lt;= 0 ? 1e-5 : alpha;
#&gt;   beta = beta &lt;= 0 ? 1e-5 : beta;
#&gt;   alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;   beta = is_inf(beta) ? 1e8 : beta; 
#&gt;   // calculate pmf
#&gt;   trunc_pmf = gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta);
#&gt;   for (i in 1:n){
#&gt;     pmf[i] = (gamma_cdf(y[i] + 1, alpha, beta) - gamma_cdf(y[i], alpha, beta)) / 
#&gt;     trunc_pmf;
#&gt;   }
#&gt;   return(pmf);
#&gt; }
#&gt; 
#&gt; // discretised truncated lognormal pmf
#&gt; vector discretised_lognormal_pmf(int[] y, real mu, real sigma, int max_val) {
#&gt;   int n = num_elements(y);
#&gt;   vector[n] pmf;
#&gt;   real small = 1e-5;
#&gt;   real c_sigma = sigma &lt;= 0 ? small : sigma;
#&gt;   real c_mu = mu &lt;= 0 ? small : mu;
#&gt;   vector[n] adj_y = to_vector(y) + small;
#&gt;   vector[n] upper_y = (log(adj_y + 1) - c_mu) / c_sigma;
#&gt;   vector[n] lower_y = (log(adj_y) - c_mu) / c_sigma;
#&gt;   real max_cdf = normal_cdf((log(max_val + small) - c_mu) / c_sigma, 0.0, 1.0);
#&gt;   real min_cdf = normal_cdf((log(small) - c_mu) / c_sigma, 0.0, 1.0);
#&gt;   real trunc_cdf = max_cdf - min_cdf;
#&gt;   for (i in 1:n) {
#&gt;     pmf[i] = (normal_cdf(upper_y[i], 0.0, 1.0) - normal_cdf(lower_y[i], 0.0, 1.0)) /
#&gt;     trunc_cdf;
#&gt;   }
#&gt;   return(pmf);
#&gt; }
#&gt; 
#&gt; // reverse a mf
#&gt; vector reverse_mf(vector pmf, int max_pmf) {
#&gt;   vector[max_pmf] rev_pmf;
#&gt;   for (d in 1:max_pmf) {
#&gt;     rev_pmf[d] = pmf[max_pmf - d + 1];
#&gt;   }
#&gt;   return rev_pmf;
#&gt; }
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector rev_pmf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pmf = num_elements(rev_pmf);
#&gt;     vector[t] conv_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         conv_cases[s] += dot_product(cases[max(1, (s - max_pmf + 1)):s],
#&gt;                                      tail(rev_pmf, min(max_pmf, s)));
#&gt;     }
#&gt;    return(conv_cases);
#&gt;   }
#&gt; 
#&gt; 
#&gt; // convolve latent infections to reported (but still unobserved) cases
#&gt; vector convolve_to_report(vector infections, 
#&gt;                           real[] delay_mean, 
#&gt;                           real[] delay_sd,
#&gt;                           int[] max_delay,
#&gt;                           int seeding_time) {
#&gt;   int t = num_elements(infections);
#&gt;   vector[t - seeding_time] reports;
#&gt;   vector[t] unobs_reports = infections;
#&gt;   int delays = num_elements(delay_mean);
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       vector[max_delay[s]] pmf = rep_vector(1e-5, max_delay[s]);
#&gt;       int delay_indexes[max_delay[s]];
#&gt;       for (i in 1:max_delay[s]) {
#&gt;         delay_indexes[i] = max_delay[s] - i;
#&gt;       }
#&gt;       pmf = pmf + discretised_lognormal_pmf(delay_indexes, delay_mean[s],
#&gt;                                             delay_sd[s], max_delay[s]);
#&gt;       unobs_reports = convolve(unobs_reports, pmf);
#&gt;     }
#&gt;     reports = unobs_reports[(seeding_time + 1):t];
#&gt;   }else{
#&gt;     reports = infections[(seeding_time + 1):t];
#&gt;   }
#&gt;   return(reports);
#&gt; }
#&gt; 
#&gt; void delays_lp(real[] delay_mean, real[] delay_mean_mean, real[] delay_mean_sd, 
#&gt;                real[] delay_sd, real[] delay_sd_mean, real[] delay_sd_sd, int weight){
#&gt;     int delays = num_elements(delay_mean);
#&gt;     if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * weight;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * weight;
#&gt;     }
#&gt;   }
#&gt; }
#&gt; 
#&gt; // eigenvalues for approximate hilbert space gp
#&gt; // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; real lambda(real L, int m) {
#&gt;   real lam;
#&gt;   lam = ((m*pi())/(2*L))^2;
#&gt;   return lam;
#&gt; }
#&gt; // eigenfunction for approximate hilbert space gp
#&gt; // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; vector phi(real L, int m, vector x) {
#&gt;   vector[rows(x)] fi;
#&gt;   fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt;   return fi;
#&gt; }	
#&gt; // spectral density of the exponential quadratic kernal
#&gt; real spd_se(real alpha, real rho, real w) {
#&gt;   real S;
#&gt;   S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt;   return S;
#&gt; }
#&gt; // spectral density of the Matern 3/2 kernel
#&gt; real spd_matern(real alpha, real rho, real w) {
#&gt;   real S;
#&gt;   S = 4*alpha^2 * (sqrt(3)/rho)^3 * 1/((sqrt(3)/rho)^2 + w^2)^2;
#&gt;   return S;
#&gt; }
#&gt; // setup gaussian process noise dimensions
#&gt; int setup_noise(int ot_h, int t, int horizon, int estimate_r, 
#&gt;                 int stationary, int future_fixed, int fixed_from) {
#&gt;   int noise_time = estimate_r &gt; 0 ? (stationary &gt; 0 ? ot_h : ot_h - 1) : t;
#&gt;   int noise_terms =  future_fixed &gt; 0 ? (noise_time - horizon + fixed_from) : noise_time; 
#&gt;   return(noise_terms);
#&gt; }
#&gt; // setup approximate gaussian process
#&gt; matrix setup_gp(int M, real L, int dimension) {
#&gt;   vector[dimension] time;
#&gt;   matrix[dimension, M] PHI;
#&gt;   real half_dim = dimension / 2.0;
#&gt;   for (s in 1:dimension) {
#&gt;     time[s] = (s - half_dim) / half_dim;
#&gt;   }
#&gt;   for (m in 1:M){ 
#&gt;     PHI[,m] = phi(L, m, time); 
#&gt;   }
#&gt;   return(PHI);
#&gt; }
#&gt; // update gaussian process using spectral densities
#&gt; vector update_gp(matrix PHI, int M, real L, real alpha, 
#&gt;                  real rho, vector eta, int type) {
#&gt;   vector[M] diagSPD;    // spectral density
#&gt;   vector[M] SPD_eta;    // spectral density * noise
#&gt;   int noise_terms = rows(PHI);
#&gt;   vector[noise_terms] noise = rep_vector(1e-6, noise_terms);
#&gt;   real unit_rho = rho / noise_terms;
#&gt;   // GP in noise - spectral densities
#&gt;   if (type == 0) {
#&gt;     for(m in 1:M){ 
#&gt;       diagSPD[m] =  sqrt(spd_se(alpha, unit_rho, sqrt(lambda(L, m)))); 
#&gt;     }
#&gt;   }else if (type == 1) {
#&gt;     for(m in 1:M){ 
#&gt;       diagSPD[m] =  sqrt(spd_matern(alpha, unit_rho, sqrt(lambda(L, m)))); 
#&gt;     }
#&gt;   }
#&gt;   SPD_eta = diagSPD .* eta;
#&gt;   noise = noise + PHI[,] * SPD_eta;
#&gt;   return(noise);
#&gt; }
#&gt; // priors for gaussian process
#&gt; void gaussian_process_lp(real rho, real alpha, vector eta,
#&gt;                          real ls_meanlog, real ls_sdlog,
#&gt;                          real ls_min, real ls_max, real alpha_sd) {
#&gt;   rho ~ lognormal(ls_meanlog, ls_sdlog) T[ls_min, ls_max];
#&gt;   alpha ~ normal(0, alpha_sd);
#&gt;   eta ~ std_normal();
#&gt; }
#&gt; 
#&gt; // Update an individual breakpoint effect
#&gt; real update_breakpoints(real input_R, real[] bp_effects,
#&gt;                         int bp_index, int at_bp,
#&gt;                         int stationary) {
#&gt;   real R = input_R;
#&gt;   if (stationary) {
#&gt;     if (bp_index &gt; 0) {
#&gt;       R += sum(bp_effects[1:bp_index]);
#&gt;       }
#&gt;   }else{
#&gt;     if (at_bp) {
#&gt;       R += bp_effects[bp_index];
#&gt;     }
#&gt;   }               
#&gt;   return(R);
#&gt; }
#&gt; // update an individual R
#&gt; real update_R(vector R, vector noise, int noise_terms,
#&gt;               int index, int stationary) {
#&gt;   real cR = R[index];
#&gt;   if (noise_terms &gt; 0) {
#&gt;     if (stationary){
#&gt;       if (index &lt;= noise_terms) {
#&gt;         cR += noise[index];
#&gt;       }else{
#&gt;         if (index &gt; 1) {
#&gt;            cR = R[index - 1];
#&gt;         }
#&gt;       }
#&gt;     }else{
#&gt;       if (index &lt;= (noise_terms + 1)) {
#&gt;         cR = R[index - 1] + noise[index - 1];
#&gt;       }else{
#&gt;         cR = R[index - 1];
#&gt;       }
#&gt;     }
#&gt;   }
#&gt;   return(cR);
#&gt; }
#&gt; // update a vector of Rts
#&gt; vector update_Rt(vector input_R, real log_R, vector noise, int[] bps,
#&gt;                  real[] bp_effects, int stationary) {
#&gt;   // define control parameters
#&gt;   int noise_terms = num_elements(noise);
#&gt;   int i_stationary = noise_terms &gt; 0 ? stationary : 1;
#&gt;   int t = num_elements(input_R);
#&gt;   int bp_n = num_elements(bp_effects);
#&gt;   int bp_in = 0;
#&gt;   int at_bp = 0;
#&gt;   int index;
#&gt;   vector[t] R;
#&gt;   // initialise Rt
#&gt;   if (i_stationary) {
#&gt;     R = rep_vector(log_R, t);
#&gt;     index = 1;
#&gt;   }else{
#&gt;     R[1] = log_R;
#&gt;     index = 2;
#&gt;   }
#&gt;   // iteratively update Rt
#&gt;   for (s in index:t) {
#&gt;     R[s] = update_R(R, noise, noise_terms, s, i_stationary);
#&gt;     if (bp_n &gt; 0) {
#&gt;       at_bp = bps[s];
#&gt;       bp_in += at_bp;
#&gt;       R[s] = update_breakpoints(R[s], bp_effects, bp_in, at_bp, i_stationary);
#&gt;     }
#&gt;   }
#&gt;   // convert to correct scale
#&gt;   R = exp(R);
#&gt;   return(R);
#&gt; }
#&gt; // Rt priors
#&gt; void rt_lp(vector log_R, real[] initial_infections, real[] initial_growth,
#&gt;            real[] bp_effects, real[] bp_sd, int bp_n, int seeding_time,
#&gt;            real r_logmean, real r_logsd, real prior_infections, 
#&gt;            real prior_growth) {
#&gt;   // prior on R
#&gt;   log_R ~ normal(r_logmean, r_logsd);
#&gt;   //breakpoint effects on Rt
#&gt;   if (bp_n &gt; 0) {
#&gt;     bp_sd[1] ~ normal(0, 0.1) T[0,];
#&gt;     bp_effects ~ normal(0, bp_sd[1]);
#&gt;   }
#&gt;   // initial infections
#&gt;   initial_infections ~ normal(prior_infections, 0.2);
#&gt;   if (seeding_time &gt; 1) {
#&gt;     initial_growth ~ normal(prior_growth, 0.2);
#&gt;   }
#&gt; }
#&gt; 
#&gt; // calculate infectiousness (weighted sum of the generation time and infections)
#&gt; // for a single time point
#&gt; real update_infectiousness(vector infections, vector gt_pmf,
#&gt;                            int seeding_time, int max_gt, int index){
#&gt;   int inf_start = max(1, (index + seeding_time - max_gt));
#&gt;   int inf_end = (index + seeding_time - 1);
#&gt;   int pmf_accessed = min(max_gt, index + seeding_time - 1);
#&gt;   real new_inf = dot_product(infections[inf_start:inf_end], tail(gt_pmf, pmf_accessed));
#&gt;   return(new_inf);
#&gt; }
#&gt; // generate infections by using Rt = Rt-1 * sum(reversed generation time pmf * infections)
#&gt; vector generate_infections(vector oR, int uot, 
#&gt;                            real[] gt_mean, real[] gt_sd, int max_gt,
#&gt;                            real[] initial_infections, real[] initial_growth,
#&gt;                            int pop, int ht) {
#&gt;   // time indices and storage
#&gt;   int ot = num_elements(oR);
#&gt;   int nht = ot - ht;
#&gt;   int t = ot + uot;
#&gt;   vector[ot] R = oR;
#&gt;   real exp_adj_Rt;
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   vector[ot] cum_infections = rep_vector(0, ot);
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot);
#&gt;   // generation time pmf
#&gt;   vector[max_gt] gt_pmf = rep_vector(1e-5, max_gt);   
#&gt;   int gt_indexes[max_gt];
#&gt;   for (i in 1:(max_gt)) {
#&gt;     gt_indexes[i] = max_gt - i + 1;
#&gt;   }
#&gt;   gt_pmf = gt_pmf + discretised_gamma_pmf(gt_indexes, gt_mean[1], gt_sd[1], max_gt);
#&gt;   // Initialise infections using daily growth
#&gt;   infections[1] = exp(initial_infections[1]);
#&gt;   if (uot &gt; 1) {
#&gt;     for (s in 2:uot) {
#&gt;       infections[s] = exp(initial_infections[1] + initial_growth[1] * (s - 1));
#&gt;     }
#&gt;   }
#&gt;   // calculate cumulative infections
#&gt;   if (pop) {
#&gt;     cum_infections[1] = sum(infections[1:uot]);
#&gt;   }
#&gt;   // iteratively update infections
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, uot, max_gt, s);
#&gt;     if (pop &amp;&amp; s &gt; nht) {
#&gt;       exp_adj_Rt = exp(-R[s] * infectiousness[s] / (pop - cum_infections[nht]));
#&gt;       exp_adj_Rt = exp_adj_Rt &gt; 1 ? 1 : exp_adj_Rt;
#&gt;       infections[s + uot] = (pop - cum_infections[s]) * (1 - exp_adj_Rt);
#&gt;     }else{
#&gt;       infections[s + uot] += R[s] * infectiousness[s];
#&gt;     }
#&gt;     if (pop &amp;&amp; s &lt; ot) {
#&gt;       cum_infections[s + 1] = cum_infections[s] + infections[s + uot];
#&gt;     }
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; // backcalculate infections using mean shifted cases and non-parametric noise
#&gt; vector deconvolve_infections(vector shifted_cases, vector noise, int fixed) {
#&gt;   int t = num_elements(shifted_cases);
#&gt;   vector[t] infections = rep_vector(1e-5, t);
#&gt;   if(!fixed) {
#&gt;     infections = infections + shifted_cases .* exp(noise);
#&gt;   }else{
#&gt;     infections = infections + shifted_cases;
#&gt;   }
#&gt;   return(infections);
#&gt; }
#&gt; // Update the log density for the generation time distribution mean and sd
#&gt; void generation_time_lp(real[] gt_mean, real gt_mean_mean, real gt_mean_sd, 
#&gt;                         real[] gt_sd, real gt_sd_mean, real gt_sd_sd, int weight) {
#&gt;     target += normal_lpdf(gt_mean[1] | gt_mean_mean, gt_mean_sd) * weight;
#&gt;     target += normal_lpdf(gt_sd[1] | gt_sd_mean, gt_sd_sd) * weight;
#&gt; }
#&gt; 
#&gt; 
#&gt; // apply day of the week effect
#&gt; vector day_of_week_effect(vector reports, int[] day_of_week, vector effect) {
#&gt;   int t = num_elements(reports);
#&gt;   // scale day of week effect
#&gt;   vector[7] scaled_effect = 7 * effect;
#&gt;   vector[t] scaled_reports;
#&gt;   for (s in 1:t) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     scaled_reports[s] = reports[s] * scaled_effect[day_of_week[s]];
#&gt;    }
#&gt;   return(scaled_reports);
#&gt; }
#&gt; // Scale observations by fraction reported and update log density of 
#&gt; // fraction reported
#&gt; vector scale_obs(vector reports, real frac_obs) {
#&gt;   int t = num_elements(reports);
#&gt;   vector[t] scaled_reports;
#&gt;   scaled_reports = reports * frac_obs;
#&gt;   return(scaled_reports);
#&gt; }
#&gt; // Calculate a truncation CMF
#&gt; vector truncation_cmf(real trunc_mean, real trunc_sd, int trunc_max) {
#&gt;     int  trunc_indexes[trunc_max];
#&gt;     vector[trunc_max] cmf;
#&gt;     for (i in 1:(trunc_max)) {
#&gt;       trunc_indexes[i] = i - 1;
#&gt;     }
#&gt;     cmf = discretised_lognormal_pmf(trunc_indexes, trunc_mean, trunc_sd, trunc_max);   
#&gt;     cmf[1] = cmf[1] + 1e-8;
#&gt;     cmf = cumulative_sum(cmf);
#&gt;     cmf = reverse_mf(cmf, trunc_max);
#&gt;     return(cmf);
#&gt; }
#&gt; // Truncate observed data by some truncation distribution
#&gt; vector truncate(vector reports, real[] truncation_mean, real[] truncation_sd, 
#&gt;                 int[] truncation_max, int reconstruct) {
#&gt;   int t = num_elements(reports);
#&gt;   int truncation = num_elements(truncation_mean);
#&gt;   vector[t] trunc_reports = reports;
#&gt;   if (truncation) {
#&gt;     // Calculate cmf of truncation delay
#&gt;     int trunc_max = truncation_max[1] &gt; t ? t : truncation_max[1];
#&gt;     int  trunc_indexes[trunc_max];
#&gt;     vector[trunc_max] cmf;
#&gt;     int first_t = t - trunc_max + 1;
#&gt;     cmf = truncation_cmf(truncation_mean[1], truncation_sd[1], trunc_max);
#&gt;     // Apply cdf of truncation delay to truncation max last entries in reports
#&gt;     if (reconstruct) {
#&gt;       trunc_reports[first_t:t] = trunc_reports[first_t:t] ./ cmf;
#&gt;     }else{
#&gt;       trunc_reports[first_t:t] = trunc_reports[first_t:t] .* cmf;
#&gt;     }
#&gt;   }
#&gt;   return(trunc_reports);
#&gt; }
#&gt; // Truncation distribution priors
#&gt; void truncation_lp(real[] truncation_mean, real[] truncation_sd, 
#&gt;                    real[] trunc_mean_mean, real[] trunc_mean_sd, 
#&gt;                    real[] trunc_sd_mean, real[] trunc_sd_sd) {
#&gt;   int truncation = num_elements(truncation_mean);
#&gt;   if (truncation) {
#&gt;     truncation_mean ~ normal(trunc_mean_mean, trunc_mean_sd);
#&gt;     truncation_sd ~ normal(trunc_sd_mean, trunc_sd_sd);
#&gt;   }                     
#&gt; }
#&gt; // update log density for reported cases
#&gt; void report_lp(int[] cases, vector reports, 
#&gt;                real[] rep_phi, int phi_prior,
#&gt;                int model_type, real weight) {
#&gt;   real sqrt_phi;
#&gt;   if (model_type) {
#&gt;     // the reciprocal overdispersion parameter (phi)
#&gt;     rep_phi[model_type] ~ normal(0, phi_prior) T[0,];
#&gt;     sqrt_phi = 1 / sqrt(rep_phi[model_type]);
#&gt;     // defer to poisson if phi is large, to avoid overflow
#&gt;     if (sqrt_phi &gt; 1e4) {
#&gt;       target += poisson_lpmf(cases | reports) * weight;
#&gt;     } else {
#&gt;       target += neg_binomial_2_lpmf(cases | reports, sqrt_phi) * weight;
#&gt;     }
#&gt;   } else {
#&gt;     target += poisson_lpmf(cases | reports) * weight;
#&gt;   }
#&gt; }
#&gt; 
#&gt; // calculate Rt directly from inferred infections
#&gt; vector calculate_Rt(vector infections, int seeding_time,
#&gt;                     real gt_mean, real gt_sd, int max_gt,
#&gt;                     int smooth) {
#&gt;   vector[max_gt] gt_pmf;  
#&gt;   int gt_indexes[max_gt];
#&gt;   int t = num_elements(infections);
#&gt;   int ot = t - seeding_time;
#&gt;   vector[ot] R;
#&gt;   vector[ot] sR;
#&gt;   vector[ot] infectiousness = rep_vector(1e-5, ot); 
#&gt;   // calculate PMF of the generation time
#&gt;   for (i in 1:(max_gt)) {
#&gt;     gt_indexes[i] = max_gt - i + 1;
#&gt;   }
#&gt;   gt_pmf = discretised_gamma_pmf(gt_indexes, gt_mean, gt_sd, max_gt);
#&gt;   // calculate Rt using Cori et al. approach
#&gt;   for (s in 1:ot) {
#&gt;     infectiousness[s] += update_infectiousness(infections, gt_pmf, seeding_time, max_gt, s);
#&gt;     R[s] = infections[s + seeding_time] / infectiousness[s];
#&gt;   }
#&gt;   if (smooth) {
#&gt;     for (s in 1:ot) {
#&gt;       real window = 0;
#&gt;       sR[s] = 0;
#&gt;       for (i in max(1, s - smooth):min(ot, s + smooth)) {
#&gt;         sR[s] += R[i];
#&gt;         window += 1;
#&gt;       }
#&gt;       sR[s] = sR[s] / window;
#&gt;     }
#&gt;   }else{
#&gt;     sR = R;
#&gt;   }
#&gt;   return(sR);
#&gt; }
#&gt; // Convert an estimate of Rt to growth
#&gt; real[] R_to_growth(vector R, real gt_mean, real gt_sd) {
#&gt;   real k = pow(gt_sd / gt_mean, 2);
#&gt;   int t = num_elements(R);
#&gt;   real r[t];
#&gt;   for (s in 1:t) {
#&gt;     r[s] = (pow(R[s], k) - 1) / (k * gt_mean);
#&gt;   } 
#&gt;   return(r);
#&gt; }
#&gt; // sample reported cases from the observation model
#&gt; int[] report_rng(vector reports, real[] rep_phi, int model_type) {
#&gt;   int t = num_elements(reports);
#&gt;   int sampled_reports[t];
#&gt;   real sqrt_phi;
#&gt;   if (model_type) {
#&gt;     sqrt_phi = 1 / sqrt(rep_phi[model_type]);
#&gt;     for (s in 1:t) {
#&gt;       // defer to poisson if phi is large, to avoid overflow
#&gt;       if (sqrt_phi &gt; 1e4) {
#&gt;         sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;       } else {
#&gt;         sampled_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s], sqrt_phi);
#&gt;       }
#&gt;     }
#&gt;   }else {
#&gt;     for (s in 1:t) {
#&gt;       sampled_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt;   return(sampled_reports);
#&gt; }
#&gt; 
#&gt; 
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt; 
#&gt;   int t;                                            // unobserved time
#&gt;   int seeding_time;                                 // time period used for seeding and not observed
#&gt;   int horizon;                                      // forecast horizon
#&gt;   int future_time;                                  // time in future for Rt
#&gt;   int&lt;lower = 0&gt; cases[t - horizon - seeding_time]; // observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;               // prior infections (for backcalculation)
#&gt; 
#&gt;   int delays;                  // no. of delay distributions
#&gt;   real delay_mean_sd[delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays];       // maximum incubation period
#&gt; 
#&gt;   real L;				                     // boundary value for infections gp
#&gt;   int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt;   real ls_meanlog;                   // meanlog for gp lengthscale prior
#&gt;   real ls_sdlog;                     // sdlog for gp lengthscale prior
#&gt;   real&lt;lower=0&gt; ls_min;              // Lower bound for the lengthscale  
#&gt;   real&lt;lower=0&gt; ls_max;              // Upper bound for the lengthscale
#&gt;   real alpha_sd;                     // standard deviation of the alpha gp kernal parameter
#&gt;   int gp_type;                       // type of gp, 0 = squared exponential, 1 = 3/2 matern
#&gt;   int stationary;                    // is underlying gaussian process first or second order
#&gt;   int fixed;                         //  should a gaussian process be used
#&gt; 
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt; 
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real prior_infections;             // prior for initial infections
#&gt;   real prior_growth;                 // prior on initial growth rate
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   int bp_n;                          // no of breakpoints (0 = no breakpoints)
#&gt;   int breakpoints[t - seeding_time]; // when do breakpoints occur 
#&gt;   int future_fixed;                  // is underlying future Rt assumed to be fixed
#&gt;   int fixed_from;                    // Reference date for when Rt estimation should be fixed
#&gt;   int pop;                           // Initial susceptible population
#&gt;   int rt_half_window;                // Half the moving average window used when calculating Rt
#&gt; 
#&gt;   int day_of_week[t - seeding_time]; // day of the week indicator (1 - 7)
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int week_effect;                   // should a day of the week effect be estimated
#&gt;   int truncation;                    // 1/0 indicating if truncation should be adjusted for
#&gt;   real trunc_mean_mean[truncation];  // truncation mean of mean
#&gt;   real trunc_mean_sd[truncation];    // truncation sd of mean
#&gt;   real trunc_sd_mean[truncation];    // truncation mean of sd
#&gt;   real trunc_sd_sd[truncation];      // truncation sd of sd
#&gt;   int max_truncation[truncation];    // maximum truncation supported
#&gt;   int obs_scale;                     // logical controlling scaling of observations
#&gt;   real obs_scale_mean;               // mean scaling factor for observations
#&gt;   real obs_scale_sd;                 // standard deviation of observation scaling
#&gt;   real obs_weight;                   // weight given to observation in log density
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   // observations
#&gt;   int ot = t - seeding_time - horizon;  // observed time
#&gt;   int ot_h = ot + horizon;  // observed time + forecast horizon
#&gt;   // gaussian process
#&gt;   int noise_terms = setup_noise(ot_h, t, horizon, estimate_r, stationary, future_fixed, fixed_from);
#&gt;   matrix[noise_terms, M] PHI = setup_gp(M, L, noise_terms);  // basis function 
#&gt;   // Rt
#&gt;   real r_logmean = log(r_mean^2 / sqrt(r_sd^2 + r_mean^2)); 
#&gt;   real r_logsd = sqrt(log(1 + (r_sd^2 / r_mean^2))); 
#&gt; }
#&gt; 
#&gt; parameters{
#&gt;   // gaussian process
#&gt;   real&lt;lower = ls_min,upper=ls_max&gt; rho[fixed ? 0 : 1];  // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];     // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;                // unconstrained noise
#&gt;   // Rt
#&gt;   vector[estimate_r] log_R;                 // baseline reproduction number estimate (log)
#&gt;   real initial_infections[estimate_r] ;     // seed infections 
#&gt;   real initial_growth[estimate_r &amp;&amp; seeding_time &gt; 1 ? 1 : 0]; // seed growth rate
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];     // mean of generation time
#&gt;   real&lt;lower = 0&gt; gt_sd[estimate_r];       // sd of generation time
#&gt;   real&lt;lower = 0&gt; bp_sd[bp_n &gt; 0 ? 1 : 0]; // standard deviation of breakpoint effect
#&gt;   real bp_effects[bp_n];                  // Rt breakpoint effects
#&gt;   // observation model
#&gt;   real delay_mean[delays];                // mean of delays
#&gt;   real delay_sd[delays];                 // sd of delays
#&gt;   simplex[week_effect ? 7 : 1] day_of_week_simplex;   // day of week reporting effect 
#&gt;   real&lt;lower = 0&gt; frac_obs[obs_scale];   // fraction of cases that are ultimately observed
#&gt;   real truncation_mean[truncation];      // mean of truncation
#&gt;   real truncation_sd[truncation];        // sd of truncation
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];   // overdispersion of the reporting process
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise  generated by the gaussian process
#&gt;   vector[estimate_r &gt; 0 ? ot_h : 0] R;                    // reproduction number
#&gt;   vector[t] infections;                                   // latent infections
#&gt;   vector[ot_h] reports;                                   // estimated reported cases
#&gt;   vector[ot] obs_reports;                                 // observed estimated reported cases
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     noise = update_gp(PHI, M, L, alpha[1], rho[1], eta, gp_type);
#&gt;   }
#&gt;   // Estimate latent infections
#&gt;   if (estimate_r) {
#&gt;     // via Rt
#&gt;     R = update_Rt(R, log_R[estimate_r], noise, breakpoints, bp_effects, stationary);
#&gt;     infections = generate_infections(R, seeding_time, gt_mean, gt_sd, max_gt,
#&gt;                                      initial_infections, initial_growth,
#&gt;                                      pop, future_time);
#&gt;   }else{
#&gt;     // via deconvolution
#&gt;     infections = deconvolve_infections(shifted_cases, noise, fixed);
#&gt;   }
#&gt;   // convolve from latent infections to mean of observations
#&gt;   reports = convolve_to_report(infections, delay_mean, delay_sd, max_delay, seeding_time);
#&gt;  // weekly reporting effect
#&gt;  if (week_effect) {
#&gt;    reports = day_of_week_effect(reports, day_of_week, day_of_week_simplex);
#&gt;   }
#&gt;   // scaling of reported cases by fraction oberserved
#&gt;  if (obs_scale) {
#&gt;    reports = scale_obs(reports, frac_obs[1]);
#&gt;  }
#&gt;  // truncate near time cases to observed reports 
#&gt;  obs_reports = truncate(reports[1:ot], truncation_mean, truncation_sd, max_truncation, 0);
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;     gaussian_process_lp(rho[1], alpha[1], eta, ls_meanlog, 
#&gt;                         ls_sdlog, ls_min, ls_max, alpha_sd);
#&gt;   }
#&gt;   // penalised priors for delay distributions
#&gt;   delays_lp(delay_mean, delay_mean_mean, delay_mean_sd, delay_sd, delay_sd_mean, delay_sd_sd, t);
#&gt;   // priors for truncation
#&gt;   truncation_lp(truncation_mean, truncation_sd, trunc_mean_mean, trunc_mean_sd, 
#&gt;                 trunc_sd_mean, trunc_sd_sd);
#&gt;   if (estimate_r) {
#&gt;     // priors on Rt
#&gt;     rt_lp(log_R, initial_infections, initial_growth, bp_effects, bp_sd, bp_n, seeding_time,
#&gt;           r_logmean, r_logsd, prior_infections, prior_growth);
#&gt;     // penalised_prior on generation interval
#&gt;     generation_time_lp(gt_mean, gt_mean_mean, gt_mean_sd, gt_sd, gt_sd_mean, gt_sd_sd, ot);
#&gt;   }
#&gt;   // prior observation scaling
#&gt;   if (obs_scale) {
#&gt;     frac_obs[1] ~ normal(obs_scale_mean, obs_scale_sd) T[0,];
#&gt;   }
#&gt;   // observed reports from mean of reports
#&gt;   report_lp(cases, obs_reports, rep_phi, 1, model_type, obs_weight);
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[ot_h]; 
#&gt;   vector[estimate_r &gt; 0 ? 0: ot_h] gen_R;
#&gt;   real r[ot_h];
#&gt;   if (estimate_r){
#&gt;     // estimate growth from estimated Rt
#&gt;     r = R_to_growth(R, gt_mean[1], gt_sd[1]);
#&gt;   }else{
#&gt;     // sample generation time
#&gt;     real gt_mean_sample = normal_rng(gt_mean_mean, gt_mean_sd);
#&gt;     real gt_sd_sample = normal_rng(gt_sd_mean, gt_sd_sd);
#&gt;     // calculate Rt using infections and generation time
#&gt;     gen_R = calculate_Rt(infections, seeding_time, gt_mean_sample, gt_mean_sample, 
#&gt;                          max_gt, rt_half_window);
#&gt;     // estimate growth from calculated Rt
#&gt;     r = R_to_growth(gen_R, gt_mean_sample, gt_sd_sample);
#&gt;   }
#&gt;   // simulate reported cases
#&gt;   imputed_reports = report_rng(reports, rep_phi, model_type);
#&gt; } 
#&gt; 
#&gt; $method
#&gt; [1] "vb"
#&gt; 
#&gt; $trials
#&gt; [1] 10
#&gt; 
#&gt; $iter
#&gt; [1] 10000
#&gt; 
#&gt; $output_samples
#&gt; [1] 2000
#&gt; </div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by <a href='https://www.samabbott.co.uk/'>Sam Abbott</a>, Joel Hellewell, Robin Thompson, Katelyn Gostic, Katharine Sherratt, Hamada S. Badr, Michael DeWitt, Sophie Meakin, James Munday, Nikos Bosse, Joe Hickson, EpiForecasts, <a href='https://www.lshtm.ac.uk/aboutus/people/funk.sebastian'>Sebastian Funk</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
   </div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script>
<script>
  docsearch({
    
    
    apiKey: '43da981922253a06c4dfab7b53f2410e',
    indexName: 'epinow2',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>



  </body>
</html>


